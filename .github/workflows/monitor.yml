name: Vercel Error Monitor

on:
  schedule:
    # Run every 6 hours (reduced from 30 min to conserve GitHub Actions minutes)
    - cron: "0 */6 * * *"
  workflow_dispatch: # Allow manual trigger from GitHub UI

jobs:
  monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      # Fetch Vercel logs using REST API (more reliable than CLI in CI)
      - name: Fetch Vercel logs
        id: logs
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: prj_W31dDW0Ekdsn4G3Ufz4VxPEg8a9s
          VERCEL_TEAM_ID: team_K5YfQm6u9dAQGJT6txaCOmoF
        run: |
          # Step 1: Get the latest production deployment
          echo "Fetching latest production deployment..."
          DEPLOYMENTS=$(curl -s -H "Authorization: Bearer $VERCEL_TOKEN" \
            "https://api.vercel.com/v6/deployments?projectId=$VERCEL_PROJECT_ID&teamId=$VERCEL_TEAM_ID&target=production&limit=1&state=READY")

          DEPLOYMENT_ID=$(echo "$DEPLOYMENTS" | jq -r '.deployments[0].uid // empty')

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "Could not find a production deployment."
            echo "API response: $DEPLOYMENTS"
            echo "has_errors=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          DEPLOYMENT_URL=$(echo "$DEPLOYMENTS" | jq -r '.deployments[0].url // empty')
          echo "Latest deployment: $DEPLOYMENT_ID ($DEPLOYMENT_URL)"

          # Step 2: Fetch runtime logs for this deployment (last 6 hours)
          # Use the log drain events API or runtime logs
          SINCE=$(date -d '6 hours ago' +%s000 2>/dev/null || date -v-6H +%s000 2>/dev/null || echo "")

          RAW_LOGS=$(curl -s -H "Authorization: Bearer $VERCEL_TOKEN" \
            "https://api.vercel.com/v2/deployments/$DEPLOYMENT_ID/events?teamId=$VERCEL_TEAM_ID&limit=500&direction=backward" 2>/dev/null || true)

          if [ -z "$RAW_LOGS" ] || [ "$RAW_LOGS" = "[]" ] || [ "$RAW_LOGS" = "null" ]; then
            echo "No logs retrieved from API."

            # Fallback: Try the Vercel CLI with project linking
            npm i -g vercel 2>/dev/null
            mkdir -p .vercel
            echo "{\"projectId\":\"$VERCEL_PROJECT_ID\",\"orgId\":\"$VERCEL_TEAM_ID\"}" > .vercel/project.json
            RAW_LOGS=$(timeout 20 vercel logs "$DEPLOYMENT_URL" --token "$VERCEL_TOKEN" 2>&1 || true)

            if [ -z "$RAW_LOGS" ]; then
              echo "No logs from CLI fallback either."
              echo "has_errors=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          echo "Logs retrieved. Scanning for errors..."

          # Step 3: Filter for errors
          # Handle both JSON array format (API) and plain text (CLI)
          if echo "$RAW_LOGS" | jq -e '.[0]' >/dev/null 2>&1; then
            # JSON format from API - extract error-level log entries
            ERRORS=$(echo "$RAW_LOGS" | jq -r '.[] | select(.type == "stderr" or .type == "error" or (.text // "" | test("(?i)(error|ERR|500|exception|unhandled|fatal|TypeError|ReferenceError)"))) | .text // .message // ""' 2>/dev/null | head -100 || true)
          else
            # Plain text format from CLI
            ERRORS=$(echo "$RAW_LOGS" | grep -iE "(error|ERR|500|exception|unhandled|fatal|ENOENT|TypeError|ReferenceError)" | head -100 || true)
          fi

          if [ -z "$ERRORS" ]; then
            echo "No errors found. All clear. âœ…"
            echo "has_errors=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found errors:"
          echo "$ERRORS"

          # Save errors for Claude to read
          echo "$ERRORS" > /tmp/vercel-errors.txt
          echo "has_errors=true" >> "$GITHUB_OUTPUT"

      # Fetch centralized application logs (Stripe, webhooks, contact, AI, etc.)
      - name: Fetch centralized app logs
        id: app_logs
        env:
          LOG_API_SECRET: ${{ secrets.LOG_API_SECRET }}
          BASE_URL: https://www.meantforgreatness.org
        run: |
          SINCE=$(date -u -d '6 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-6H +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "")

          if [ -z "$LOG_API_SECRET" ]; then
            echo "LOG_API_SECRET not configured â€” skipping centralized log check."
            echo "has_app_errors=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          APP_LOGS=$(curl -sf -H "Authorization: Bearer $LOG_API_SECRET" \
            "$BASE_URL/api/admin/logs?level=error&since=$SINCE&limit=100" 2>/dev/null || echo "")

          if [ -z "$APP_LOGS" ]; then
            echo "Could not fetch centralized logs (API may be unreachable)."
            echo "has_app_errors=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          ERROR_COUNT=$(echo "$APP_LOGS" | jq '.pagination.total // 0' 2>/dev/null || echo "0")

          if [ "$ERROR_COUNT" = "0" ]; then
            echo "No application-level errors in centralized logs. âœ…"
            echo "has_app_errors=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found $ERROR_COUNT application-level errors in centralized logs."
          echo "$APP_LOGS" | jq -r '.data[] | "\(.createdAt) [\(.level)] [\(.source)] \(.message)"' > /tmp/app-errors.txt
          echo "has_app_errors=true" >> "$GITHUB_OUTPUT"

      # Create a GitHub issue to notify about the errors
      - name: Create issue for detected errors
        if: steps.logs.outputs.has_errors == 'true' || steps.app_logs.outputs.has_app_errors == 'true'
        id: issue
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERCEL_ERRORS=""
          if [ -f /tmp/vercel-errors.txt ]; then
            VERCEL_ERRORS=$(cat /tmp/vercel-errors.txt)
          fi

          APP_ERRORS=""
          if [ -f /tmp/app-errors.txt ]; then
            APP_ERRORS=$(cat /tmp/app-errors.txt)
          fi

          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M UTC")

          BODY="## Production Errors Detected

          The automated monitor found errors at **$TIMESTAMP**."

          if [ -n "$VERCEL_ERRORS" ]; then
            BODY="$BODY

          ### Vercel Runtime Errors
          \`\`\`
          $VERCEL_ERRORS
          \`\`\`"
          fi

          if [ -n "$APP_ERRORS" ]; then
            BODY="$BODY

          ### Application Errors (Centralized Logs)
          \`\`\`
          $APP_ERRORS
          \`\`\`"
          fi

          BODY="$BODY

          ### Status
          â³ Claude Haiku is analyzing these errors and attempting to create a fix PR...

          ---
          *This issue was created automatically by the [Error Monitor](https://github.com/${{ github.repository }}/actions/workflows/monitor.yml)*"

          ISSUE_URL=$(gh issue create \
            --title "ðŸš¨ Production errors detected - $TIMESTAMP" \
            --label "bug,automated" \
            --body "$BODY")

          echo "issue_url=$ISSUE_URL" >> "$GITHUB_OUTPUT"
          echo "Created issue: $ISSUE_URL"

      # Install dependencies only if errors found (saves CI time on clean runs)
      - name: Install dependencies
        if: steps.logs.outputs.has_errors == 'true' || steps.app_logs.outputs.has_app_errors == 'true'
        run: npm ci

      # If errors found, let Claude analyze and fix
      - name: Claude analyzes and fixes errors
        id: claude
        if: steps.logs.outputs.has_errors == 'true' || steps.app_logs.outputs.has_app_errors == 'true'
        continue-on-error: true
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Install Claude Code
          npm i -g @anthropic-ai/claude-code

          VERCEL_ERRORS=""
          if [ -f /tmp/vercel-errors.txt ]; then
            VERCEL_ERRORS=$(cat /tmp/vercel-errors.txt)
          fi

          APP_ERRORS=""
          if [ -f /tmp/app-errors.txt ]; then
            APP_ERRORS=$(cat /tmp/app-errors.txt)
          fi

          ALL_ERRORS="=== Vercel Runtime Errors ===
          $VERCEL_ERRORS

          === Application Errors (Centralized Logs) ===
          $APP_ERRORS"

          claude -p \
            --model claude-haiku \
            --allowedTools "Read,Edit,Bash(npm test),Bash(npm run test),Bash(git checkout -b *),Bash(git add *),Bash(git commit *),Bash(git push *),Bash(gh pr create *),Bash(git diff *),Bash(git status),Bash(git config *)" \
            "You are an automated error-fixing agent. Here are production errors:

          \`\`\`
          $ALL_ERRORS
          \`\`\`

          Please:
          1. Analyze these errors and identify the root cause
          2. Find the relevant source files in this repo
          3. Create a fix on a new branch (use format: fix/auto-$(date +%Y-%m-%d)-description)
          4. Run tests to verify the fix works
          5. Push the branch and create a PR with a clear description of what broke and how you fixed it

          If the errors are transient (network timeouts, rate limits, etc.) and not caused by our code, just log your analysis and do NOT create a PR." \
          2>&1 | tee /tmp/claude-output.txt

      # Update the issue with Claude's result
      - name: Update issue with results
        if: steps.logs.outputs.has_errors == 'true' || steps.app_logs.outputs.has_app_errors == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CLAUDE_OUTPUT=$(cat /tmp/claude-output.txt 2>/dev/null || echo "No output captured")
          # Truncate if too long for a comment
          if [ ${#CLAUDE_OUTPUT} -gt 60000 ]; then
            CLAUDE_OUTPUT="${CLAUDE_OUTPUT:0:60000}... (truncated)"
          fi

          if [ "${{ steps.claude.outcome }}" == "success" ]; then
            gh issue comment "${{ steps.issue.outputs.issue_url }}" --body "$(cat <<EOF
          ## âœ… Claude Haiku Analysis Complete

          Claude analyzed the errors and took action. Check for a new PR linked to this issue.

          <details>
          <summary>Claude's full output</summary>

          \`\`\`
          $CLAUDE_OUTPUT
          \`\`\`

          </details>
          EOF
          )"
          else
            gh issue comment "${{ steps.issue.outputs.issue_url }}" --body "$(cat <<EOF
          ## âŒ Claude could not fix the errors automatically

          The automated fix attempt failed. Please investigate manually.

          <details>
          <summary>Claude's output</summary>

          \`\`\`
          $CLAUDE_OUTPUT
          \`\`\`

          </details>

          ---
          **Next steps:** Open Claude Code locally and investigate these production errors.
          EOF
          )"
          fi
